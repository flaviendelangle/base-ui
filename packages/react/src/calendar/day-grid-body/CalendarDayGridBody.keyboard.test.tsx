import * as React from 'react';
import { spy } from 'sinon';
import { Calendar } from '@base-ui/react/calendar';
import { act, screen } from '@mui/internal-test-utils';
import { createTemporalRenderer } from '#test-utils';

describe('<Calendar.DayGridBody /> - keyboard navigation', () => {
  const { render, adapter } = createTemporalRenderer();

  function renderUncontrolledCalendar(
    defaultDate: ReturnType<ReturnType<typeof createTemporalRenderer>['adapter']['date']>,
    onVisibleDateChange?: ReturnType<typeof spy>,
  ) {
    return render(
      <Calendar.Root defaultVisibleDate={defaultDate} onVisibleDateChange={onVisibleDateChange}>
        <Calendar.DayGrid>
          <Calendar.DayGridBody>
            {(week) => (
              <Calendar.DayGridRow value={week} key={week.toString()}>
                {(day) => (
                  <Calendar.DayGridCell value={day} key={day.toString()}>
                    <Calendar.DayButton />
                  </Calendar.DayGridCell>
                )}
              </Calendar.DayGridRow>
            )}
          </Calendar.DayGridBody>
        </Calendar.DayGrid>
      </Calendar.Root>,
    );
  }

  /** Queries a day button by its full accessible name (e.g. "Saturday, February 15, 2025"). */
  function getDayButton(
    date: ReturnType<ReturnType<typeof createTemporalRenderer>['adapter']['date']>,
  ) {
    return screen.getByRole('button', {
      name: adapter.format(date, 'localizedDateWithFullMonthAndWeekDay'),
    });
  }

  // ---------------------------------------------------------------------------
  // PageDown / PageUp
  // ---------------------------------------------------------------------------

  describe('PageDown', () => {
    it('should move focus to the same day in the next month when pressing PageDown', async () => {
      const onVisibleDateChange = spy();
      const date = adapter.date('2025-02-15', 'default');

      const { user } = renderUncontrolledCalendar(date, onVisibleDateChange);

      await act(async () => {
        getDayButton(date).focus();
      });
      await user.keyboard('[PageDown]');

      expect(onVisibleDateChange.callCount).to.equal(1);
      expect(onVisibleDateChange.firstCall.args[1].reason).to.equal('keyboard');
      const newDate = adapter.addMonths(date, 1);
      expect(onVisibleDateChange.firstCall.args[0]).toEqual(adapter.startOfMonth(newDate));
      expect(getDayButton(newDate)).toHaveFocus();
    });
  });

  describe('PageUp', () => {
    it('should move focus to the same day in the previous month when pressing PageUp', async () => {
      const onVisibleDateChange = spy();
      const date = adapter.date('2025-02-15', 'default');

      const { user } = renderUncontrolledCalendar(date, onVisibleDateChange);

      await act(async () => {
        getDayButton(date).focus();
      });
      await user.keyboard('[PageUp]');

      expect(onVisibleDateChange.callCount).to.equal(1);
      expect(onVisibleDateChange.firstCall.args[1].reason).to.equal('keyboard');
      const newDate = adapter.addMonths(date, -1);
      expect(onVisibleDateChange.firstCall.args[0]).toEqual(adapter.startOfMonth(newDate));
      expect(getDayButton(adapter.addMonths(date, -1))).toHaveFocus();
    });
  });

  describe('Shift+PageDown', () => {
    it('should move focus to the same day 12 months forward when pressing Shift+PageDown', async () => {
      const onVisibleDateChange = spy();
      const date = adapter.date('2025-02-15', 'default');

      const { user } = renderUncontrolledCalendar(date, onVisibleDateChange);

      await act(async () => {
        getDayButton(date).focus();
      });
      await user.keyboard('[ShiftLeft>][PageDown][/ShiftLeft]');

      expect(onVisibleDateChange.callCount).to.equal(1);
      expect(onVisibleDateChange.firstCall.args[1].reason).to.equal('keyboard');
      const newDate = adapter.addMonths(date, 12);
      expect(onVisibleDateChange.firstCall.args[0]).toEqual(adapter.startOfMonth(newDate));
      expect(getDayButton(newDate)).toHaveFocus();
    });
  });

  describe('Shift+PageUp', () => {
    it('should move focus to the same day 12 months backward when pressing Shift+PageUp', async () => {
      const onVisibleDateChange = spy();
      const date = adapter.date('2025-02-15', 'default');

      const { user } = renderUncontrolledCalendar(date, onVisibleDateChange);

      await act(async () => {
        getDayButton(date).focus();
      });
      await user.keyboard('[ShiftLeft>][PageUp][/ShiftLeft]');

      expect(onVisibleDateChange.callCount).to.equal(1);
      expect(onVisibleDateChange.firstCall.args[1].reason).to.equal('keyboard');
      const newDate = adapter.addMonths(date, -12);
      expect(onVisibleDateChange.firstCall.args[0]).toEqual(adapter.startOfMonth(newDate));
      expect(getDayButton(newDate)).toHaveFocus();
    });
  });

  // ---------------------------------------------------------------------------
  // Arrow navigation - within the same month
  //
  // February 2025 grid (en-US locale, weeks start Sunday):
  //   Week 1: Jan 26(disabled) … Feb 1(Sat, index 6)
  //   Week 2: Feb 2(Sun) … Feb 8(Sat, index 13)
  //   Week 3: Feb 9(Sun) … Feb 15(Sat, index 20)
  //   Week 4: Feb 16(Sun) … Feb 22(Sat, index 27)
  //   Week 5: Feb 23(Sun) … Feb 28(Fri, index 33), Mar 1(disabled, index 34)
  // ---------------------------------------------------------------------------

  describe('ArrowRight', () => {
    it('should move focus to the next day', async () => {
      const feb14 = adapter.date('2025-02-14', 'default');
      const feb15 = adapter.date('2025-02-15', 'default');

      const { user } = renderUncontrolledCalendar(adapter.startOfMonth(feb14));

      await act(async () => {
        getDayButton(feb14).focus();
      });
      await user.keyboard('{ArrowRight}');

      expect(getDayButton(feb15)).toHaveFocus();
    });

    // July 2021 ends on Saturday: Jul 31 is the very last cell of the 5-week
    // grid (index 34). There is no trailing outside-month day, so the onLoop
    // guard does not block navigation and the month wraps to August 2021.
    // handleItemLooping(ArrowRight, 34) → newHighlightedIndex = 0
    // August 2021 starts on Sunday → index 0 = Aug 1 (in-month, enabled).
    it('should wrap to the next month and focus the first day when on the last day', async () => {
      const onVisibleDateChange = spy();
      const jul31 = adapter.date('2021-07-31', 'default');
      const aug1 = adapter.date('2021-08-01', 'default');

      const { user } = renderUncontrolledCalendar(adapter.startOfMonth(jul31), onVisibleDateChange);

      await act(async () => {
        getDayButton(jul31).focus();
      });
      await user.keyboard('{ArrowRight}');

      expect(onVisibleDateChange.callCount).to.equal(1);
      expect(onVisibleDateChange.firstCall.args[1].reason).to.equal('keyboard');
      expect(onVisibleDateChange.firstCall.args[0]).toEqual(adapter.startOfMonth(aug1));
      expect(getDayButton(aug1)).toHaveFocus();
    });
  });

  describe('ArrowLeft', () => {
    it('should move focus to the previous day', async () => {
      const feb15 = adapter.date('2025-02-15', 'default');
      const feb14 = adapter.date('2025-02-14', 'default');

      const { user } = renderUncontrolledCalendar(adapter.startOfMonth(feb15));

      await act(async () => {
        getDayButton(feb15).focus();
      });
      await user.keyboard('{ArrowLeft}');

      expect(getDayButton(feb14)).toHaveFocus();
    });

    // August 2021 starts on Sunday: Aug 1 is the very first cell of the grid
    // (index 0). There is no leading outside-month day, so the onLoop guard
    // does not block navigation and the month wraps to July 2021.
    // handleItemLooping(ArrowLeft, 0) → newHighlightedIndex = 5×7-1 = 34
    // July 2021: index 34 = Jul 31 (Saturday, in-month, enabled).
    it('should wrap to the previous month and focus the last day when on the first day', async () => {
      const onVisibleDateChange = spy();
      const aug1 = adapter.date('2021-08-01', 'default');
      const jul31 = adapter.date('2021-07-31', 'default');

      const { user } = renderUncontrolledCalendar(adapter.startOfMonth(aug1), onVisibleDateChange);

      await act(async () => {
        getDayButton(aug1).focus();
      });
      await user.keyboard('{ArrowLeft}');

      expect(onVisibleDateChange.callCount).to.equal(1);
      expect(onVisibleDateChange.firstCall.args[1].reason).to.equal('keyboard');
      expect(onVisibleDateChange.firstCall.args[0]).toEqual(adapter.startOfMonth(jul31));
      expect(getDayButton(jul31)).toHaveFocus();
    });
  });

  describe('ArrowDown', () => {
    it('should move focus down one week to the same weekday', async () => {
      const feb8 = adapter.date('2025-02-08', 'default');
      const feb15 = adapter.date('2025-02-15', 'default');

      const { user } = renderUncontrolledCalendar(adapter.startOfMonth(feb8));

      await act(async () => {
        getDayButton(feb8).focus();
      });
      await user.keyboard('{ArrowDown}');

      expect(getDayButton(feb15)).toHaveFocus();
    });

    // Jul 31 (Sat, index 34) is in the last row of July 2021's 5-week grid.
    // elementsRef.current[34 + 7] is undefined (no row below), so the onLoop
    // guard does not block navigation.
    // handleItemLooping(ArrowDown, 34) → newHighlightedIndex = 34 % 7 = 6
    // August 2021: index 6 = Aug 7 (Saturday, in-month, enabled).
    it('should wrap to the next month and focus the same weekday when on the last week', async () => {
      const onVisibleDateChange = spy();
      const jul31 = adapter.date('2021-07-31', 'default');
      const aug7 = adapter.date('2021-08-07', 'default');

      const { user } = renderUncontrolledCalendar(adapter.startOfMonth(jul31), onVisibleDateChange);

      await act(async () => {
        getDayButton(jul31).focus();
      });
      await user.keyboard('{ArrowDown}');

      expect(onVisibleDateChange.callCount).to.equal(1);
      expect(onVisibleDateChange.firstCall.args[1].reason).to.equal('keyboard');
      expect(onVisibleDateChange.firstCall.args[0]).toEqual(adapter.startOfMonth(aug7));
      expect(getDayButton(aug7)).toHaveFocus();
    });

    // Mar 31, 2025 (Mon) is at index 36 in March 2025's 6-week grid.
    // handleItemLooping(ArrowDown, 36) → newHighlightedIndex = 36 % 7 = 1
    // April 2025: index 1 = Mar 31 (outside-month, disabled), so the algorithm
    // skips by +7 to index 8, which is Apr 7 (Monday, in-month, enabled).
    it('should skip disabled previous-month day in the next month when wrapping down', async () => {
      const onVisibleDateChange = spy();
      const mar31 = adapter.date('2025-03-31', 'default');
      const apr7 = adapter.date('2025-04-07', 'default');

      const { user } = renderUncontrolledCalendar(adapter.startOfMonth(mar31), onVisibleDateChange);

      await act(async () => {
        getDayButton(mar31).focus();
      });
      await user.keyboard('{ArrowDown}');

      expect(onVisibleDateChange.callCount).to.equal(1);
      expect(onVisibleDateChange.firstCall.args[1].reason).to.equal('keyboard');
      expect(onVisibleDateChange.firstCall.args[0]).toEqual(adapter.startOfMonth(apr7));
      expect(getDayButton(apr7)).toHaveFocus();
    });
  });

  describe('ArrowUp', () => {
    it('should move focus up one week to the same weekday', async () => {
      const feb15 = adapter.date('2025-02-15', 'default');
      const feb8 = adapter.date('2025-02-08', 'default');

      const { user } = renderUncontrolledCalendar(adapter.startOfMonth(feb15));

      await act(async () => {
        getDayButton(feb15).focus();
      });
      await user.keyboard('{ArrowUp}');

      expect(getDayButton(feb8)).toHaveFocus();
    });

    // Aug 1 (Sun, index 0) is in the first row of August 2021's 5-week grid.
    // elementsRef.current[0 - 7] is undefined (no row above), so the onLoop
    // guard does not block navigation.
    // handleItemLooping(ArrowUp, 0) → newHighlightedIndex = 5×7-(7-0) = 28
    // July 2021: index 28 = Jul 25 (Sunday, in-month, enabled).
    it('should wrap to the previous month and focus the same weekday when on the first week', async () => {
      const onVisibleDateChange = spy();
      const aug1 = adapter.date('2021-08-01', 'default');
      const jul25 = adapter.date('2021-07-25', 'default');

      const { user } = renderUncontrolledCalendar(adapter.startOfMonth(aug1), onVisibleDateChange);

      await act(async () => {
        getDayButton(aug1).focus();
      });
      await user.keyboard('{ArrowUp}');

      expect(onVisibleDateChange.callCount).to.equal(1);
      expect(onVisibleDateChange.firstCall.args[1].reason).to.equal('keyboard');
      expect(onVisibleDateChange.firstCall.args[0]).toEqual(adapter.startOfMonth(jul25));
      expect(getDayButton(jul25)).toHaveFocus();
    });

    // Apr 7 (Mon, index 8 in a Sun-first 6-week April grid) is in the second row.
    // ArrowUp targets index 1 (Mar 31, outside-month, disabled) → onLoop fires.
    // onLoop: setVisibleDate(March) + executeAfterItemMapUpdate
    // March grid: guessedIndex = 42 - 7 + (8 % 7) = 36 = Mar 31 (Mon, in-month, enabled).
    it('should change to previous month and focus same weekday when navigating up from the second week', async () => {
      const onVisibleDateChange = spy();
      const apr7 = adapter.date('2025-04-07', 'default');
      const mar31 = adapter.date('2025-03-31', 'default');

      const { user } = renderUncontrolledCalendar(adapter.startOfMonth(apr7), onVisibleDateChange);

      await act(async () => {
        getDayButton(apr7).focus();
      });
      await user.keyboard('{ArrowUp}');

      expect(onVisibleDateChange.callCount).to.equal(1);
      expect(onVisibleDateChange.firstCall.args[1].reason).to.equal('keyboard');
      expect(onVisibleDateChange.firstCall.args[0]).toEqual(adapter.startOfMonth(mar31));
      expect(getDayButton(mar31)).toHaveFocus();
    });
  });
});
